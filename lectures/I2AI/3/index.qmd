---
title: "Problem solving (searching)"
subtitle: "üß† I2AI_3 ‚Äî Introduction to AI"

format: 
  html:
    output-file: index.html
  revealjs:
    output-file: slides.html     
---

# Top{visibility="hidden" .slide-link-hidden .unlisted}

[Slides](slides.html){#fig-elephant}

# Problem-solving agents {.vertical-center background-color=blue background-image="images/bg-squares-planes.jpeg"}

## Agent

Agents that plan ahead by considering a sequence of actions that form a path to a goal state are called __problem-solving agents__ [@RusselNorvig2022AIMA, p.81]

::: {.incremental}
- The computational process it undertakes is __search__
- The representations the agents use are __atomic__ representations
- There are search algorithms for several environments. 
:::

::: {.fragment}
Here only __simple environments__ are considered *(episodic, single agent, fully observable, deterministic, static, discrete, and known)*.  
--> We assume that information about the environment are given (e.g., a map).
:::

:::{.notes}
There are also search algorithms for problems in *partially observable, nondeterministic, unknown, and continuous environments* (i.e., complex environments) like local search methods (e.g., hill-climbing search, local beam search, evolutionary algorithms). For details please see @RusselNorvig2022AIMA.
:::

## Problem-solving process

In simple environments, agents can follow a four-phase-problem-solving process [@RusselNorvig2022AIMA, p.81-82]:

::: {.incremental}
- __Goal formulation__: goals organize behavior by limiting the objectives and hence the actions to be considered
- __Problem formulation__: the agents devices a description of the states and actions necessary to reach the goal‚Äîan abstract model of the relevant part of the environment
- __Search__: the agent simulates sequences of actions in its model, searching until it finds a sequence that reaches the goal (i.e., the solution)
- __Execution__: the agent executes the actions in the solution, one at a time 
:::

## Search problem

A search problem can be defined formally as [@RusselNorvig2022AIMA, p.83]:

::: {.incremental}
- The __state space__: a set of possible states the environment can be in
- The __initial state__: the state that the agent starts
- __Goal states__: a singe goal state, a small set of alternative goal states, or a property that applies to many states (e.g, no dirt in any location)
- The __actions__ available to the agent `ACTIONS(s)` where `s` is the current state
- A __transition model__: describes what each action does. `RESULT(s,a)`returens the state that results from doing action `a`in state `s`.
- An __action cost function__: gives the numeric cost of applying action `a` in state `s` to reach state `s'` (`ACTION-COST(s,a,s'`)
- A __path__: a sequence of actions
- A __solution__: a path from the initial state to the goal state
:::

## Search problems are models

![Example: A simplified map of Romania, with road distances in miles; based on @RusselNorvig2022AIMA [p.82]](images/search-problem.svg){#fig-search-problem}

::: {.notes}
@fig-search-problem depicts the search problem as model, the state space graph [@RusselNorvig2022AIMA, p.82-84]:

- State space: cities (vertices, each state occurs only once)
- Initial state: Arad
- Goal state: Bucharest (goal test: `Is state == Bucharest?`)
- Actions: directed edges between the vertices (paths)
- Action costs: numbers on the paths

::: {.callout-note}
### Definition of search problems and abstraction
The model is an abstract mathematical description, here a simple atomic state description. The model is an __abstraction__ as it ignores many details of the reality (e.g., weather and scenery).

A good problem formulation has the right level of detail (i.e., an appropriate __level of abstraction__).

The choice of a good abstraction involves removing as much detail as possible while retaining validity and ensuring that the abstract actions are easy to carry out. An abstraction is *valid* if any abstract solution can be elaborated into a solution in the more detailed world.
:::

## Real world problems

Examples for search problems are [@RusselNorvig2022AIMA, p. 87-88]:

- Route-finding problems (e.g., car navigation, airline travel-planning)
- Touring problems (e.g., the traveling salesperson problem)
- VLSI layout problems (positioning millions of components and connections on a chip)
- Robot navigation (e.g., vacuum robots)
- Automatic assembly sequencing of complex objects (e.g., protein design)

:::

# Search algorithms {.vertical-center background-color=blue background-image="images/bg-squares-planes.jpeg"}

A __search algorithm__ takes a search problem as input and returns a solution, or an indication of failure [@RusselNorvig2022AIMA, p.89].

::: {.notes}
Here we consider algorithms that superimpose a search tree over the state-space graph, forming various paths from the initial state, trying to find a path that reaches a goal state.
:::

## Search trees

![Example: A partial search tree for finding a route from Arad to Bucharest; based on @RusselNorvig2022AIMA [p.89]](images/search-tree.svg){#fig-search-tree}

::: {.notes}
In @fig-search-tree, nodes that have been *expanded* are white with bold letters; nodes on the frontier that have been *generated* but not yet expanded are in white and regular letter; the set of states corresponding to these two types of nodes are said to have been *reached*. Nodes that could be generated next are shown in faint dashed lines.

::: {.callout-note}
### Definition of search trees
A search tree is a ‚Äúwhat if‚Äù tree of plans and their outcomes.

- The start state is the root node,
- children correspond to successors, 
- nodes show states, but correspond to PLANS that achieve those states

There are lots of repeated structure in the search tree. Thus, for most problems, the whole tree can never be actually built. In practice, both state space graphs and search trees are constructed on demand and as little as possible.
:::
:::


## Uniformed search

## Informed search 

# ‚úèÔ∏è Exercises {.vertical-center background-color=blue background-image="images/bg-squares-planes.jpeg"}

## I2AI_3 E1

Define in your own words the following terms: 

- ...

::: {#refs}
# References {visibility="hidden"}
:::