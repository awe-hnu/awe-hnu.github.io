<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Andy Weeger">

<title>Search &amp; Planning – awe.lectures</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<link href="../../../../assets/favicon.png" rel="icon" type="image/png">
<script src="../../../../site_libs/cookie-consent/cookie-consent.js"></script>
<link href="../../../../site_libs/cookie-consent/cookie-consent.css" rel="stylesheet">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap-30d6ba78130312a1c129854e52a348e9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="../../../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

<script type="text/javascript" charset="UTF-8">
document.addEventListener('DOMContentLoaded', function () {
cookieconsent.run({
  "notice_banner_type":"interstitial",
  "consent_type":"express",
  "palette":"dark",
  "language":"en",
  "page_load_consent_levels":["strictly-necessary"],
  "notice_banner_reject_button_hide":false,
  "preferences_center_close_button_hide":false,
  "website_name":""
  ,
"language":"en"
  });
});
</script> 
  
<meta name="robots" content="noindex">   

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<meta property="og:title" content="Search &amp; Planning – awe.lectures">
<meta property="og:description" content="Introduction to AI (I2AI)">
<meta property="og:image" content="https://awe-hnu.github.io/lectures/I2AI/25ST/search/images/search-problem.svg">
<meta property="og:site_name" content="awe.lectures">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">awe — Lecture Notes</span>
    </a>
  </div>
          <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../index.html"> 
<span class="menu-text">Start</span></a>
  </li>  
</ul>
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <a class="flex-grow-1 no-decor" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
          <h1 class="quarto-secondary-nav-title">Search &amp; Planning</h1>
        </a>     
    </div>
  </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title d-none d-lg-block">Search &amp; Planning</h1>
            <p class="subtitle lead">Introduction to AI (I2AI)</p>
                                <div class="quarto-categories">
                <div class="quarto-category">Lecture Notes</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta column-body">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Andy Weeger </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">Mar 12, 2025</p>
      </div>
    </div>
    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">Apr 1, 2025</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Admin</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="https://elearning.hnu.de/course/view.php?id=21594" class="sidebar-item-text sidebar-link" target="_blank">
 <span class="menu-text">Moodle</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../lectures/I2AI/25ST/admin/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Administrivia</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Lecture notes</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../lectures/I2AI/25ST/intro/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../lectures/I2AI/25ST/agents/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Environments &amp; Agents</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../lectures/I2AI/25ST/search/index.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Search &amp; Planning</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../lectures/I2AI/25ST/knowledge/slides.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Knowledge &amp; Inference</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar"><div class="quarto-margin-header"><div class="margin-header-item">
<p><a href="slides.html" class="btn btn-primary" target="blank">Slides</a></p>
</div></div>
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#search-problem" id="toc-search-problem" class="nav-link" data-scroll-target="#search-problem">Search problem</a></li>
  <li><a href="#search-trees" id="toc-search-trees" class="nav-link" data-scroll-target="#search-trees">Search trees</a></li>
  <li><a href="#search-algorithms" id="toc-search-algorithms" class="nav-link" data-scroll-target="#search-algorithms">Search algorithms</a></li>
  <li><a href="#player-games" id="toc-player-games" class="nav-link" data-scroll-target="#player-games">2-Player games</a></li>
  <li><a href="#monte-carlo-tree-search" id="toc-monte-carlo-tree-search" class="nav-link" data-scroll-target="#monte-carlo-tree-search">Monte Carlo tree search</a></li>
  <li><a href="#wrap-up" id="toc-wrap-up" class="nav-link" data-scroll-target="#wrap-up">Wrap-up</a></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises">Exercises</a></li>
  <li><a href="#literature" id="toc-literature" class="nav-link" data-scroll-target="#literature">Literature</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block column-body" id="quarto-document-content">





<section id="introduction" class="level1 headline-only" data-background-image="../assets/bg.jpeg">
<h1 class="headline-only" data-background-image="../assets/bg.jpeg">Introduction</h1>
<section id="planning-agents" class="level2">
<h2 data-anchor-id="planning-agents">Planning agents</h2>
<div class="notes">
<p>Rational agents perceive environmental states and choose actions to maximize long-term performance. When optimal actions aren’t obvious, agents must plan ahead by determining action sequences that efficiently move from current states to goal states.</p>
<p>Planning agents (including <a href="../agents/#goal-based-agents">goal-based</a> and <a href="../agents/#utility-based-agents">utility-based variants</a>) seek solutions for search problems—action sequences leading from start to goal states. Closely related to planning is optimization, where only finding the optimal state matters, not the path to reach it.</p>
</div>
</section>
<section id="examples" class="level2">
<h2 data-anchor-id="examples">Examples</h2>
<div class="notes">
<p>Examples for search problems are <span class="citation" data-cites="RusselNorvig2022AIMA">(<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">Russel and Norvig 2022, 87–88</a>)</span>:</p>
<ul>
<li>Route-finding problems (e.g., car navigation, airline travel-planning)</li>
<li>Touring problems (e.g., the traveling salesperson problem)</li>
<li>VLSI layout problems (positioning millions of components and connections on a chip)</li>
<li>Robot navigation (e.g., vacuum robots)</li>
<li>Automatic assembly sequencing of complex objects (e.g., protein design)</li>
</ul>
</div>
</section>
<section id="terms" class="level2">
<h2 data-anchor-id="terms">Terms</h2>
<p>Agents that plan by considering a sequence of actions that form a path to a goal are called <strong>planning agents</strong> <span class="citation" data-cites="RusselNorvig2022AIMA">(<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">Russel and Norvig 2022, 81</a>)</span>.</p>
<div class="incremental">
<ul class="incremental">
<li>The computational process it undertakes is <strong>search</strong>.</li>
<li>The representations the agents use are <strong>atomic representations</strong><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</li>
<li>The <strong>search algrotihms</strong> can be uninformed and informed.</li>
</ul>
</div>
<p>Here only <strong>simple environments</strong> are considered <em>(episodic, single agent, fully observable, deterministic, static, discrete, and known)</em>.</p>
<p>We assume that information about the environment are given (e.g., a map)</p>
<div class="notes">
<div class="small">
<p>There are also search algorithms for problems in <em>partially observable, nondeterministic, unknown, and continuous environments</em> (i.e., complex environments) like local search methods (e.g., hill-climbing search, local beam search, evolutionary algorithms). For details please see <span class="citation" data-cites="RusselNorvig2022AIMA">Russel and Norvig (<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">2022</a>)</span>.</p>
</div>
</div>
</section>
<section id="problem-solving-process" class="level2">
<h2 data-anchor-id="problem-solving-process">Problem-solving process</h2>
<p>In simple environments, agents can follow a four-phase-problem-solving process <span class="citation" data-cites="RusselNorvig2022AIMA">(<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">Russel and Norvig 2022, 81–82</a>)</span>:</p>
<div class="incremental">
<ol class="incremental" type="1">
<li><strong>Goal formulation</strong>: Identifying the objectives to be achieved based on the current situation and agent’s purpose</li>
<li><strong>Problem formulation</strong>: Deciding what states and actions to consider to achieve the goal<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></li>
<li><strong>Search</strong>: Systematically exploring possible sequences of actions to find a solution path from initial state to goal state</li>
<li><strong>Execution</strong>: Carrying out the solution actions in the environment</li>
</ol>
</div>
<div class="notes">
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Problem formulation must follow goal formulation
</div>
</div>
<div class="callout-body-container callout-body">
<p>In goal formulation, we decide which aspects of the world we are interested in, and which can be ignored or abstracted away. Then in problem formulation we decide how to manipulate the important aspects (and ignore the others). If we did problem formulation first we would not know what to include and what to leave out.</p>
<p>It can happen that there is a cycle of iterations between goal formulation, problem formulation, and problem-solving until one arrives at a sufficiently useful and efficient solution.</p>
</div>
</div>
</div>
</section>
</section>
<section id="search-problem" class="level1 headline-only" data-background-image="../assets/bg.jpeg">
<h1 class="headline-only" data-background-image="../assets/bg.jpeg">Search problem</h1>
<section id="definition" class="level2">
<h2 data-anchor-id="definition">Definition</h2>
<p>A search problem can be defined formally as <span class="citation" data-cites="RusselNorvig2022AIMA">(<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">Russel and Norvig 2022, 83</a>)</span>:</p>
<div class="incremental">
<ul class="incremental">
<li><strong>State space:</strong> a set of possible states<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> the environment can be in<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></li>
<li><strong>Initial state:</strong> the state that the agent starts</li>
<li><strong>Goal state(s):</strong> a state that the agent is trying to reach<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></li>
<li><strong>Transition model:</strong> <span class="math inline">\(\textrm{RESULT}(s,a)\)</span> — returns the state <span class="math inline">\(s'\)</span> that results from performing action <span class="math inline">\(a\)</span> in state <span class="math inline">\(s\)</span></li>
<li><strong>Successor function:</strong> <span class="math inline">\(\textrm{ACTIONS}(s)\)</span> — returns a set of (action, state) pairs for node <span class="math inline">\(s\)</span>, where the state is the state reachable by taking the action <span class="math inline">\(a\)</span></li>
<li><strong>Action cost function:</strong> <span class="math inline">\(\textrm{ACTION-COST}(s,a,s')\)</span> — gives the numeric cost of performing action <span class="math inline">\(a\)</span> in state <span class="math inline">\(s\)</span> to reach state <span class="math inline">\(s'\)</span></li>
<li><strong>Path:</strong> a sequence of actions</li>
<li><strong>Solution:</strong> a path from the initial state to the goal state</li>
</ul>
</div>
<div class="notes">
<div class="callout callout-style-simple callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Examples
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><strong>Navigation</strong></p>
<ul>
<li><strong>State space:</strong> All possible waypoints (intersections, landmarks) in the road network</li>
<li><strong>Initial state:</strong> Starting waypoint of the agent (e.g., home intersection, current street position)</li>
<li><strong>Goal state(s):</strong> Destination waypoint(s) the agent wants to reach (e.g., store intersection, airport terminal entrance)</li>
<li><strong>Transition model:</strong> Model that returns the new waypoint after traveling along a specific road segment</li>
<li><strong>Successor function:</strong> Model that returns available road segments (streets, highways) and resulting waypoints connected to current waypoint</li>
<li><strong>Action cost function:</strong> Model that returns the distance, time, or fuel consumption for traveling between waypoints (maybe influenced by speed limits, traffic, road conditions)</li>
<li><strong>Path:</strong> A sequence of road segments through the network</li>
<li><strong>Solution:</strong> A sequence of road segments from starting waypoint to destination waypoint</li>
</ul>
<p><strong>8-Puzzle</strong></p>
<ul>
<li><strong>State space:</strong> All possible configurations of the 8 numbered tiles in a 3×3 grid (with one empty space)</li>
<li><strong>Initial state:</strong> Starting arrangement of tiles (a specific configuration of the 8 tiles and empty space)</li>
<li><strong>Goal state(s):</strong> Target arrangement of tiles (typically tiles in numerical order with empty space in a specific position)</li>
<li><strong>Transition model:</strong> Model that returns the new configuration after sliding a tile into the empty space</li>
<li><strong>Successor function:</strong> AModel that returns possible slides (up, down, left, right) of adjacent tiles into the empty space and resulting configurations</li>
<li><strong>Action cost function:</strong> Typically uniform cost of 1 per move</li>
<li><strong>Path:</strong> A sequence of tile slides</li>
<li><strong>Solution:</strong> A sequence of tile slides from initial configuration to goal configuration</li>
</ul>
<p><strong>Chess</strong></p>
<ul>
<li><strong>State space:</strong> All possible legal board configurations of chess pieces</li>
<li><strong>Initial state:</strong> Standard starting position with all pieces in their traditional positions</li>
<li><strong>Goal state(s):</strong> Any board configuration where the opponent’s king is in checkmate</li>
<li><strong>Transition model:</strong> Model that returns the new board configuration after making a specific move</li>
<li><strong>Successor function:</strong> AModel that returns all legal moves and resulting board configurations from current position</li>
<li><strong>Action cost function:</strong> Typically uniform cost of 1 per move</li>
<li><strong>Path:</strong> A sequence of chess moves</li>
<li><strong>Solution:</strong> A sequence of moves from the initial position to a checkmate position</li>
</ul>
</div>
</div>
</div>
</div>
</section>
<section id="problem-formulation-modelling" class="level2">
<h2 data-anchor-id="problem-formulation-modelling">Problem formulation (modelling)</h2>
<div id="fig-search-problem" class="quarto-float quarto-figure quarto-figure-left">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-search-problem-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/search-problem.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-1" title="Figure&nbsp;1: Example: A simplified map of Romania, with road distances in miles; based on @RusselNorvig2022AIMA [p. 84]"><img src="images/search-problem.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-search-problem-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Example: A simplified map of Romania, with road distances in miles; based on <span class="citation" data-cites="RusselNorvig2022AIMA">Russel and Norvig (<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">2022, 84</a>)</span>
</figcaption>
</figure>
</div>
<div class="notes">
<p><a href="#fig-search-problem" class="quarto-xref">Figure&nbsp;1</a> depicts the search problem as model, the state space graph:</p>
<ul>
<li><strong>State space:</strong> cities (vertices, each state occurs only once)</li>
<li><strong>Initial state:</strong> Arad</li>
<li><strong>Goal state:</strong> Bucharest (goal test: <span class="math inline">\(Is state == Bucharest?\)</span>)</li>
<li><strong>Actions:</strong> directed edges between the vertices (paths)</li>
<li><strong>Action costs:</strong> numbers on the paths</li>
</ul>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Modelling &amp; abstraction
</div>
</div>
<div class="callout-body-container callout-body">
<p>The <strong>model</strong> is an abstract mathematical description, here a simple atomic state description. The model is an <strong>abstraction</strong> as it ignores many details of the reality (e.g., weather and scenery).</p>
<p><strong>Modeling</strong> as a process includes:</p>
<ul>
<li>Deciding which aspects of the real-world problem are relevant</li>
<li>Choosing appropriate abstractions and simplifications</li>
<li>Determining the right level of granularity (e.g., waypoints vs.&nbsp;coordinates)</li>
<li>Making assumptions about the problem domain</li>
<li>Selecting the suitable problem-solving paradigm (search, constraint satisfaction, optimization, etc.)</li>
</ul>
<p>A good problem formulation has the right level of detail (i.e., an appropriate <strong>level of abstraction</strong>).</p>
<p>The choice of a good abstraction involves removing as much detail as possible while retaining validity and ensuring that the abstract actions are easy to carry out. An abstraction is <em>valid</em> if any abstract solution can be elaborated into a solution in the more detailed world.</p>
</div>
</div>
</div>
</section>
</section>
<section id="search-trees" class="level1 headline-only" data-background-image="../assets/bg.jpeg">
<h1 class="headline-only" data-background-image="../assets/bg.jpeg">Search trees</h1>
<section id="definition-1" class="level2">
<h2 data-anchor-id="definition-1">Definition</h2>
<p>The formulation of a search problem, encompassing the definition of state space, initial state, goal states, transition model, and other pertinent elements, effectively constitutes the blueprint for a search tree:</p>
<div class="incremental">
<ul class="incremental">
<li>The <strong>root node</strong> of the tree corresponds to your initial state</li>
<li>The <strong>branches</strong> represent actions defined by your transition model</li>
<li>The <strong>child nodes</strong> are states resulting from taking those actions</li>
<li><strong>Leaf nodes</strong> are states with no successors (or states we choose not to expand)</li>
<li><strong>Goal nodes</strong> are states that satisfy your goal condition</li>
</ul>
</div>
<p>The search tree is the computational manifestation of your problem formulation.</p>
<div class="notes">
<p>The quality of your your problem formulation directly affects:</p>
<ul>
<li>The structure of the tree (branching factor, depth)</li>
<li>The efficiency of search algorithms traversing it</li>
<li>The quality of solutions found</li>
</ul>
<p>For example, in the 8-puzzle problem, a poor modeling choice might represent the entire board as a single entity, while a better model would represent each tile position individually, resulting in a more manageable search tree.</p>
<div class="callout callout-style-simple callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Modelling choice examples
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><strong>Continuous coordinate system modeling approach</strong></p>
<p>If we model navigation using precise GPS coordinates (latitude/longitude): - States would be exact positions: <code>(37.7749, -122.4194)</code> - Actions would be small movements in any direction - Transition model would calculate new coordinates based on direction and distance</p>
<p>This approach creates problems:</p>
<ol type="1">
<li><strong>Enormous state space</strong>: infinite possible positions</li>
<li><strong>Unrealistic movement model</strong>: doesn’t account for road constraints</li>
<li><strong>Inefficient search</strong>: most coordinates don’t correspond to valid paths</li>
<li><strong>Complex cost calculation</strong>: difficult to determine if movement between coordinates is even possible</li>
</ol>
<p><strong>Waypoint graph modeling approach</strong></p>
<p>A better approach models the problem as a graph of waypoints:</p>
<ul>
<li><strong>States</strong>: discrete locations (intersections, landmarks): <code>node_123</code></li>
<li><strong>Actions</strong>: road segments connecting waypoints: <code>take_main_street</code></li>
<li><strong>Transition model</strong>: graph edges showing direct connections</li>
<li><strong>Cost function</strong>: actual road distances, travel times, or other metrics</li>
</ul>
<p>Benefits of this approach:</p>
<ol type="1">
<li><strong>Drastically reduced state space</strong>: only meaningful locations are represented</li>
<li><strong>Realistic movement model</strong>: only follows actual roads</li>
<li><strong>Efficient search</strong>: branching factor limited to connected roads</li>
<li><strong>Accurate cost calculation</strong>: based on real road metrics (distance, speed limits, traffic)</li>
</ol>
<p>The waypoint model transforms an infinite continuous problem into a finite discrete one, making the search tree dramatically smaller and focused only on relevant states. This allows standard search algorithms like A* to efficiently find optimal routes in reasonable time frames, even for large maps.</p>
</div>
</div>
</div>
</div>
</section>
<section id="frontier" class="level2">
<h2 data-anchor-id="frontier">Frontier</h2>
<p>The frontier (sometimes called the “open list” or “fringe”) is the collection of nodes that have been generated but not yet expanded or evaluated.</p>
<p>The frontier serves as the boundary between explored and unexplored parts of the search space. It contains all the nodes that are immediate candidates for expansion.</p>
<div class="medium">
<p>You might also call the frontier the “to-do list” of nodes that the search algorithm maintains.</p>
</div>
</section>
<section id="example" class="level2">
<h2 data-anchor-id="example">Example</h2>
<div id="fig-search-tree" class="quarto-float quarto-figure quarto-figure-left">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-search-tree-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/search-tree.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-2" title="Figure&nbsp;2: Example: A partial search tree for finding a route from Arad to Bucharest; based on @RusselNorvig2022AIMA"><img src="images/search-tree.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-search-tree-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Example: A partial search tree for finding a route from Arad to Bucharest; based on <span class="citation" data-cites="RusselNorvig2022AIMA">Russel and Norvig (<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">2022</a>)</span>
</figcaption>
</figure>
</div>
<div class="notes">
<p><a href="#fig-search-tree" class="quarto-xref">Figure&nbsp;2</a> visualizes a partial search tree: the first few steps in finding a path from <em>Arad</em> (initial state) to <em>Bucharest</em> (goal).</p>
<ul>
<li>The <strong>root node</strong> of the search tree is the initial state <span class="math inline">\(s\)</span> <em>(Arad)</em></li>
<li>The available actions per state can be queried using <span class="math inline">\(ACTIONS(s)\)</span></li>
<li>The current node is <strong>expanded</strong> by generating <strong>child nodes</strong> or <strong>successor nodes</strong> using the available actions and <span class="math inline">\(RESULT(s,a)\)</span></li>
<li>Each resulting child node has <em>Arad</em> as its <strong>parent node</strong></li>
<li>The <strong>frontier</strong> contains all not yet expanded nodes</li>
<li>The child node to be considered next is selected by the minimum value of some <strong>evaluation function</strong> <span class="math inline">\(f(n)\)</span></li>
</ul>
<div class="smaller">
<p>In <a href="#fig-search-tree" class="quarto-xref">Figure&nbsp;2</a>, nodes that have been expanded are white with bold letters; nodes on the <strong>frontier</strong> that have been generated but not yet expanded are in white and regular letters; the set of states corresponding to these two types of nodes are said to have been <strong>reached</strong>. Nodes that could be generated next are shown in faint dashed lines.</p>
</div>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition of search trees
</div>
</div>
<div class="callout-body-container callout-body">
<p>A search tree is a “what if” tree of plans and their outcomes.</p>
<ul>
<li>The start state is the root node,</li>
<li>children correspond to successors,</li>
<li>nodes show states, but correspond to PLANS that achieve those states</li>
</ul>
<p>There are lots of repeated structure in the search tree. Thus, for most problems, the whole tree can never be actually built. In practice, both state space graphs and search trees are constructed on demand and as little as possible <span class="citation" data-cites="RusselNorvig2022AIMA">(<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">Russel and Norvig 2022</a>)</span>.</p>
</div>
</div>
<p>Search algorithms require a data structure to keep track of the <strong>search tree</strong>. A node in the tree is represented by a data structure with four components <span class="citation" data-cites="RusselNorvig2022AIMA">(<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">Russel and Norvig 2022, 91</a>)</span>:</p>
<ul>
<li><em>node.STATE</em>: the state to which the node corresponds</li>
<li><em>node.PARENT</em>: the node in the tree that generated this node</li>
<li><em>node.ACTION</em>: the action that was applied to the parent’s state to generate this node</li>
<li><em>node.PATH-COST</em>: the total cost of the path from the initial state to generate this node</li>
</ul>
<p>Following the PARENT pointers back from a node allows to revocer the states and actions along the path to that node. Doing this from a goal node generates the solution.</p>
<div class="callout callout-style-simple callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Example data structure in pseudo code
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">var</span> searchTree <span class="op">=</span> {</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  node<span class="op">.</span><span class="at">STATE</span><span class="op">:</span> <span class="st">"Bucharest"</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  node<span class="op">.</span><span class="at">PARENT</span><span class="op">:</span> {</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    node<span class="op">.</span><span class="at">STATE</span><span class="op">:</span> <span class="st">"Pitesti"</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    node<span class="op">.</span><span class="at">PARENT</span><span class="op">:</span> {</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      node<span class="op">.</span><span class="at">STATE</span><span class="op">:</span> <span class="st">"Rimmicu Vilcea"</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>      node<span class="op">.</span><span class="at">PARENT</span><span class="op">:</span> {</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        node<span class="op">.</span><span class="at">STATE</span><span class="op">:</span> <span class="st">"Sibiu"</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        node<span class="op">.</span><span class="at">PARENT</span><span class="op">:</span> {</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>          node<span class="op">.</span><span class="at">STATE</span><span class="op">:</span> <span class="st">"Arad"</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>          node<span class="op">.</span><span class="at">PARENT</span><span class="op">:</span> NULL</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>          node<span class="op">.</span><span class="at">ACTION</span><span class="op">:</span> NULL</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>          node<span class="op">.</span><span class="at">PATH</span><span class="op">-</span><span class="dt">COST</span><span class="op">:</span> <span class="dv">0</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        node<span class="op">.</span><span class="at">ACTION</span><span class="op">:</span> <span class="st">"Arad to Sibiu"</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        node<span class="op">.</span><span class="at">PATH</span><span class="op">-</span><span class="dt">COST</span><span class="op">:</span> <span class="dv">140</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>      node<span class="op">.</span><span class="at">ACTION</span><span class="op">:</span> <span class="st">"Sibiu to Rimmicu Vilcea"</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>      node<span class="op">.</span><span class="at">PATH</span><span class="op">-</span><span class="dt">COST</span><span class="op">:</span> <span class="dv">220</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    node<span class="op">.</span><span class="at">ACTION</span><span class="op">:</span> <span class="st">"Rimmicu Vilcea to Pitesti"</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    node<span class="op">.</span><span class="at">PATH</span><span class="op">-</span><span class="dt">COST</span><span class="op">:</span> <span class="dv">317</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>  node<span class="op">.</span><span class="at">ACTION</span><span class="op">:</span> <span class="st">"Pitesti to Bucharest"</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>  node<span class="op">.</span><span class="at">PATH</span><span class="op">-</span><span class="dt">COST</span><span class="op">:</span> <span class="dv">418</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</div>
</div>
</div>
<p>In addition, a data structure to store the <strong>frontier</strong> is neded. Usually this is realized using a <strong>queue</strong> with following functions <span class="citation" data-cites="RusselNorvig2022AIMA">(<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">Russel and Norvig 2022, 91</a>)</span>:</p>
<ul>
<li><em>IS-EMPTY(frontier)</em>: returns true only if there are no nodes in the frontier</li>
<li><em>POP(frontier)</em>: removes the top node from the frontier and returns it</li>
<li><em>TOP(frontier)</em>: returns (but does not remove) the top node from the frontier</li>
<li><em>ADD(node,frontier)</em>: inserts node into its proper place in the queue</li>
</ul>
</div>
</section>
</section>
<section id="search-algorithms" class="level1 headline-only" data-background-image="../assets/bg.jpeg">
<h1 class="headline-only" data-background-image="../assets/bg.jpeg">Search algorithms</h1>
<section id="definition-2" class="level2">
<h2 data-anchor-id="definition-2">Definition</h2>
<p><strong>Search algorithms</strong> take a search problem as input and return a solution, or an indication of failure <span class="citation" data-cites="RusselNorvig2022AIMA">(<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">Russel and Norvig 2022, 89</a>)</span>.</p>
<div class="incremental">
<ul class="incremental">
<li>They superimpose a search tree over the state-space graph,</li>
<li>form various paths from the initial state, and</li>
<li>try to find a path that reaches a goal state.</li>
</ul>
</div>
<p>Depending on the problem formulation, they can implement different methods:</p>
<div class="incremental">
<ul class="incremental">
<li><strong>Uninformed search</strong>, which only have access to the problem definition but not clue about how close a state is to the goal(s).</li>
<li><strong>Informed search</strong>, which have access to a heuristic function that gives domain-specific hints about how close a state is to the goal(s) <em>(e.g., using straight-line distance in route-finding problems)</em></li>
</ul>
</div>
</section>
<section id="performance-metrics" class="level2">
<h2 data-anchor-id="performance-metrics">Performance metrics</h2>
<p>Performance metrics guide the choice of algorithms based on problem requirements, help predict computational demands, and establish clear expectations about what an algorithm can and cannot do.</p>
<div class="notes">
<p><strong>Completeness</strong> refers to an algorithm’s guarantee to find a solution if one exists, ensuring that no potential solution path is overlooked during the search process. This property is crucial in critical applications where finding any viable solution is mandatory, such as medical diagnosis systems or emergency response planning, as it provides certainty that the algorithm won’t fail by getting stuck in infinite loops or dead ends.</p>
<p><strong>Optimality</strong> ensures that an algorithm will find not just any solution, but the best possible one according to a defined cost function, whether that’s shortest distance, minimum time, lowest energy consumption, or other metrics. This property is essential in resource-constrained environments where efficiency matters significantly, such as route planning, supply chain optimization, or bandwidth allocation, as it guarantees maximum value from available resources.</p>
<p><strong>Complexity</strong> measures how an algorithm’s resource requirements (time and memory) scale with increasing problem size, typically expressed using big O notation in terms of factors like branching factor and solution depth. Understanding complexity helps predict whether an algorithm will be practically usable for real-world problems or if it will exceed available computational resources, making it a critical consideration when deploying algorithms in time-sensitive applications or on hardware with limited capabilities.</p>
<p><strong>Global solutions</strong> provide a complete path from initial state to goal state, offering step-by-step instructions for transitioning between states, whereas <strong>local solutions</strong> focus only on finding an optimal or good state without specifying how to reach it. This distinction is important because global solution algorithms (like A* or BFS) are essential for navigation and planning tasks requiring explicit paths, while local solution approaches (like hill climbing or genetic algorithms) can be more efficient for optimization problems where only the final configuration matters, not the route taken to achieve it.</p>
</div>
</section>
<section id="uninformed-search" class="level2">
<h2 data-anchor-id="uninformed-search">Uninformed search</h2>
<div id="fig-search-strategies" class="quarto-float quarto-figure quarto-figure-left">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-search-strategies-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/strategies.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-3" title="Figure&nbsp;3: Overview of uninformed search strategies"><img src="images/strategies.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-search-strategies-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Overview of uninformed search strategies
</figcaption>
</figure>
</div>
<section id="breadth-first-search" class="level3" data-visibility="hidden">
<h3 data-visibility="hidden" data-anchor-id="breadth-first-search">Breadth-first search</h3>
<ol type="1">
<li>Start from the initial node.</li>
<li>Expand node by applying all available actions of this state and obtain the corresponding sucessor states.</li>
<li>Select next state to expand, which is the topmost not yet expanded node.</li>
<li><code>If</code> the selected node is the goal-state, terminate and return path from initial to goal-state; <code>Else</code> continue with step 2.</li>
</ol>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Is complete and optimal for unit action costs.</li>
<li>Exponential space complexity — all generated nodes have to be stored until the solution is found.</li>
<li><strong>FIFO queue<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></strong></li>
</ul>
</section>
<section id="depth-first-search" class="level3" data-visibility="hidden">
<h3 data-visibility="hidden" data-anchor-id="depth-first-search">Depth-first search</h3>
<ol type="1">
<li>Start from the initial node.</li>
<li>Expand node by applying all available actions of this state and obtain the corresponding sucessor states.</li>
<li>Select next state to expand, which is the deepest not yet expanded node.</li>
<li><code>If</code> the selected node is the goal-state, terminate and return path from initial to goal-state; <code>Else</code> continue with step 2.</li>
</ol>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Is neither complete (in infinite state spaces, it can get stock going down an infinite path) nor optimal.</li>
<li>A depth bound can be added.</li>
<li>Linear space complexity — the frontier is very small as subtrees, which have been traversed completely without finding a solution, can be removed, before new subtrees are generated.</li>
<li><strong>LIFO queue<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></strong></li>
</ul>
</section>
<section id="uniform-cost-search" class="level3" data-visibility="hidden">
<h3 data-visibility="hidden" data-anchor-id="uniform-cost-search">Uniform-cost search</h3>
<ol type="1">
<li>Start from the initial node.</li>
<li>Expand node by applying all available actions of this state and obtain the corresponding sucessor states.</li>
<li>Select next state to expand, which is the not yet expanded node, with the lowest accumulated costs.</li>
<li><code>If</code> the selected node is the goal-state, terminate and return path from initial to goal-state; <code>Else</code> continue with step 2</li>
</ol>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Is complete, optimal for general action costs.</li>
<li><strong>Priority queue<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></strong> using cumulative cost.</li>
</ul>
<div class="notes">
<div class="callout callout-style-simple callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-7-contents" aria-controls="callout-7" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Illustration of strategies
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-7" class="callout-7-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><span class="h4">Breadth-first</span></p>
<p><strong>General process</strong></p>
<ol type="1">
<li>Add the start node to the frontier using <span class="math inline">\(ADD(node,frontier)\)</span></li>
<li>Get the top node from the frontier using <span class="math inline">\(POP(frontier)\)</span></li>
<li>Get all the actions avaible for the top node via <span class="math inline">\(ACTIONS(s)\)</span></li>
<li>Get the child nodes for the retreived actions via <span class="math inline">\(RESULT(s,a)\)</span></li>
<li>Check if one child nodes is a goal state; if yes return the search tree; if not go ahead</li>
<li>Add the child nodes to the frontier <span class="math inline">\(ADD(node,frontier)\)</span></li>
<li>Repeat steps 2 to 6 as long as no solution is found and <span class="math inline">\(IS-EMPTY(frontier)\)</span> is not true</li>
</ol>
<p><strong>Example</strong></p>
<p>Example using the tree depicted in <a href="#fig-search-tree" class="quarto-xref">Figure&nbsp;2</a>, assuming that the goal is not included:</p>
<div class="small">
<ul>
<li>Add <em>0</em> to the frontier</li>
<li>Get the top node from the frontier (<em>0</em>)</li>
<li>Get the actions avaiable from <em>0</em> (<em>to 1</em> and <em>to 2</em>)</li>
<li>Get the child nodes for the retrieved actions (<em>1</em> and <em>2</em>)</li>
<li>Check if <em>1</em> is a goal state (<em>false</em>)</li>
<li>Add <em>1</em> to the frontier</li>
<li>Check if <em>2</em> is a goald state (<em>false</em>)</li>
<li>Add <em>2</em> to the frontier</li>
<li>Get the top node from the frontier, here using the FIFO (<em>1</em>)</li>
<li>Get the actions avaiable from <em>1</em> (<em>to 3</em> and <em>to 4</em>)</li>
<li>Get the child nodes for the retrieved actions (<em>3</em> and <em>4</em>)</li>
<li>Check if <em>3</em> is a goal state (<em>false</em>)</li>
<li>Add <em>3</em> to the frontier</li>
<li>Check if <em>4</em> is a goal state (<em>false</em>)</li>
<li>Add <em>4</em> to the frontier</li>
<li>Get the top node from the frontier (<em>2</em>)</li>
<li>Get the actions avaiable from <em>2</em> (<em>to 5</em> and <em>to 6</em>)</li>
<li>Get the child nodes for the retrieved actions (<em>5</em> and <em>6</em>)</li>
<li>Check if <em>5</em> is a goal state (<em>false</em>)</li>
<li>Add <em>5</em> to the frontier</li>
<li>Check if <em>6</em> is a goal state (<em>false</em>)</li>
<li>Add <em>6</em> to the frontier</li>
<li>Get the top node from the frontier (<em>3</em>)</li>
<li>…</li>
</ul>
</div>
<p><span class="h4">Depth-first</span></p>
<p><strong>General process</strong></p>
<p>The overall process is the same, only the frontier queue returns the node that was added last.</p>
<p><span class="h4">Uniform-cost</span></p>
<p><strong>General process</strong></p>
<p>The overall process is the same, only the frontier queue returns the node in the queue with the minimum : cost-paths.</p>
<p><strong>Example</strong></p>
<p>Example using the tree depicted in <a href="#fig-search-problem" class="quarto-xref">Figure&nbsp;1</a>:</p>
<div class="small">
<ul>
<li>Add <em>Arad</em> to the frontier</li>
<li>Get the top node from the frontier (<em>Arad</em>)</li>
<li>Get the actions avaiable from <em>Arad</em> (<em>to Zerind</em>, <em>to Timisoara</em>, <em>to Sibiu</em>)</li>
<li>Get the child nodes for the retrieved actions (<em>Zerind</em>, <em>Timisoara</em>, <em>Sibiu</em>)</li>
<li>Add <em>Zerind</em>, <em>Timisoara</em>, and <em>Sibiu</em> to the frontier</li>
<li>Get the node from the frontier with the lowest path cost (<em>Zerind</em>)</li>
<li>Check if <em>Zerind</em> is a goal state (<em>false</em>)</li>
<li>Get the actions avaiable from <em>Zerind</em> (<em>to Oradea</em>)</li>
<li>Get the child nodes for the retrieved actions (<em>Oradea</em>)</li>
<li>Add <em>Oradea</em> to the frontier</li>
<li>Get the node from the frontier with the lowest path cost (<em>Timisoara</em>)</li>
<li>Check if <em>Timisoara</em> is a goal state (<em>false</em>)</li>
<li>Get the actions avaiable from <em>Timisoara</em> (<em>to Lugoj</em>)</li>
<li>Get the child nodes for the retrieved actions (<em>Lugoj</em>)</li>
<li>Add <em>Lugoj</em> the frontier</li>
<li>Get the node from the frontier with the lowest path cost (<em>Sibiu</em>)</li>
<li>Check if <em>Sibiu</em> is a goal state (<em>false</em>)</li>
<li>Get the actions avaiable from <em>Sibiu</em> (<em>to Fagaras</em>, <em>to Rimmicu Vilcea</em>)</li>
<li>Get the child nodes for the retrieved actions (<em>Fagaras</em>, <em>Rimmicu Vilcea</em>)</li>
<li>Add <em>Fagaras</em> and <em>Rimmicu Vilcea</em> to the frontier</li>
<li>Get the node from the frontier with the lowest path cost (<em>Rimmicu Vilcea</em>)</li>
<li>Check if <em>Rimmicu Vilcea</em> is a goal state (<em>false</em>)</li>
<li>Get the actions avaiable from <em>Rimmicu Vilcea</em> (<em>to Pitesti</em>, <em>to Craiova</em>)</li>
<li>Get the child nodes for the retrieved actions (<em>Pitesti</em>, <em>Craiova</em>)</li>
<li>Add <em>Pitesti</em> and <em>Craiova</em> to the frontier</li>
<li>Get the node from the frontier with the lowest path cost (<em>Lugoj</em>)</li>
<li>Check if <em>Lugoj</em> is a goal state (<em>false</em>)</li>
<li>Get the actions avaiable from <em>Lugoj</em> (<em>to Mehadia</em>)</li>
<li>Get the child nodes for the retrieved actions (<em>Mehadia</em>)</li>
<li>Add <em>Mehadia</em> to the frontier</li>
<li>Get the node from the frontier with the lowest path cost (<em>Fagaras</em>)</li>
<li>Check if <em>Fagaras</em> is a goal state (<em>false</em>)</li>
<li>Get the actions avaiable from <em>Fagaras</em> (<em>to Bucharest</em>)</li>
<li>Get the child nodes for the retrieved actions (<em>Bucharest</em>)</li>
<li>Add <em>Bucharest</em> to the frontier</li>
<li>Get the node from the frontier with the lowest path cost (<em>Mehadia</em>)</li>
<li>Check if <em>Mehadia</em> is a goal state (<em>false</em>)</li>
<li>Get the actions avaiable from <em>Mehadia</em> (<em>to Drobeta</em>)</li>
<li>Get the child nodes for the retrieved actions (<em>Drobeta</em>)</li>
<li>Add <em>Drobeta</em> to the frontier</li>
<li>Get the node from the frontier with the lowest path cost (<em>Pitesti</em>)</li>
<li>Check if <em>Pitesti</em> is a goal state (<em>false</em>)</li>
<li>Get the actions avaiable from <em>Pitesti</em> (<em>to Bucharest</em>, <em>to Craiova</em>)</li>
<li>Get the child nodes for the retrieved actions (<em>Bucharest</em>, <em>Craiova</em>)</li>
<li>Add <em>Bucharest</em> and <em>Craiova</em> to the frontier</li>
<li>Get the node from the frontier with the lowest path cost (<em>Drobeta</em>)</li>
<li>Check if <em>Drobeta</em> is a goal state (<em>false</em>)</li>
<li>Get the actions avaiable from <em>Drobeta</em> (<em>to Craiova</em>)</li>
<li>Get the child nodes for the retrieved actions (<em>Craiova</em>)</li>
<li>Add <em>Craiova</em> to the frontier</li>
<li>Get the node from the frontier with the lowest path cost (<em>Bucharest</em>)</li>
<li>Check if <em>Drobeta</em> is a goal state (<em>true</em>)</li>
<li>Return solution</li>
</ul>
<p>Note if we had checked for a goald upon generating a node rather than when expanding the lowest-cost node, then we would have returned a higher-cost path (the one through Fagaras)</p>
</div>
</div>
</div>
</div>
</div>
</section>
</section>
<section id="informed-search" class="level2" data-visibility="hidden">
<h2 data-visibility="hidden" data-anchor-id="informed-search">Informed search</h2>
<p>Informed (heuristic) search strategies use domain-specific hints about the location of goals <span class="citation" data-cites="RusselNorvig2022AIMA">(<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">Russel and Norvig 2022, 102</a>)</span>. These strategies can find solutions <strong>more efficiently</strong> than uninformed strategies. The hints are generated by a <strong>heuristic function</strong> <span class="math inline">\(h(n)\)</span></p>
<section id="greedy-best-first-search" class="level3">
<h3 data-anchor-id="greedy-best-first-search">Greedy best-first search</h3>
<p>The Greedy best-first search uses the evlation function <span class="math inline">\(f(n) = h(n)\)</span></p>
<p>It expands the first node with the lowest <span class="math inline">\(h(n)\)</span> value in the queue.</p>
<p>In route finding problems, the straight-line distance heuristic is used as <span class="math inline">\(h(n)\)</span>.</p>
<p>Greedy best-first graph search is complete in finite state spaces, but not in infinite ones.</p>
</section>
<section id="a-search" class="level3">
<h3 data-anchor-id="a-search">A* Search</h3>
<p>The A* search (pronounced “A-star search”) uses the evaluation function <span class="math inline">\(f(n) = g(n) + h(n)\)</span>.</p>
<div class="incremental">
<ul class="incremental">
<li><span class="math inline">\(g(n)\)</span> is the path cost from the initial state to node <span class="math inline">\(n\)</span> (e.g., computed by using the action-cost function).</li>
<li><span class="math inline">\(h(n)\)</span> is the <em>estimated cost</em> of the shortes path from <span class="math inline">\(n\)</span> to a goal state.</li>
</ul>
</div>
<p>A* search is complete, if it is cost-optimal depends on the heuristic.</p>
</section>
</section>
<section id="online-search" class="level2">
<h2 data-anchor-id="online-search">Online search</h2>
<p>The agents considered so far use <strong>offline search</strong> algorithm. They compute a complete solution before taking their first action. They are not helpful in unknown environments.</p>
<p><strong>Online search</strong> agents interleaves computation and action:</p>
<div class="incremental">
<ul class="incremental">
<li>Takes action,</li>
<li>observes the environment, and</li>
<li>computes the next action,</li>
</ul>
</div>
<p>These agents can discover successor only for a state that is occupied or that is learned (i.e., contained in a map created online)</p>
<p>Online search is a good idea in dynamic or semi-dynamic environments.</p>
</section>
</section>
<section id="player-games" class="level1 headline-only" data-background-image="../assets/bg.jpeg">
<h1 class="headline-only" data-background-image="../assets/bg.jpeg">2-Player games</h1>
<section id="example-alphago" class="level2" data-background-color="#0333ff" data-background-image="images/alphaGo.jpeg">
<h2 data-background-color="#0333ff" data-background-image="images/alphaGo.jpeg" data-anchor-id="example-alphago">Example: AlphaGo</h2>
<div class="notes">
<p>AlphaGo is a computer program that plays the board game Go, which is considered much more difficult for computers to win than other games such as chess because its strategic and aesthetic nature makes it difficult to construct a direct scoring function. AlphaGo was developed by the London-based DeepMind Technologies, an acquired subsidiary of Alphabet Inc.&nbsp;</p>
<div id="fig-alphaGo" class="quarto-float quarto-figure quarto-figure-left">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-alphaGo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/alphaGo.jpeg" class="lightbox" data-gallery="quarto-lightbox-gallery-4" title="Figure&nbsp;4: A human trying to beat AlphaGo"><img src="images/alphaGo.jpeg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-alphaGo-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: A human trying to beat AlphaGo
</figcaption>
</figure>
</div>
<p>AlphaGo use a <strong>Monte Carlo tree search algorithm</strong> to find their moves based on knowledge previously acquired through machine learning, specifically an artificial neural network (a deep learning method) through extensive training, both from human and computer games. A neural network is trained to recognize the best moves and the winning rates of those moves. This neural network improves the strength of the tree search, leading to stronger move selection in the next iteration. It is used to decide on</p>
<ul>
<li>the next action to choose in the selection-phase,</li>
<li>which leaf-node to extend in the expansion phase, and</li>
<li>which actions to choose in the simulation phase</li>
</ul>
<p>A nice summary of MCTS and AlphaGo can be found <a href="https://www.analyticsvidhya.com/blog/2019/01/monte-carlo-tree-search-introduction-algorithm-deepmind-alphago/">here</a>.</p>
</div>
</section>
<section id="adversarial-search" class="level2">
<h2 data-anchor-id="adversarial-search">Adversarial search</h2>
<p>In <strong>competitive</strong> environments, two or more agents have conflicting goals, which gives rise to <strong>adversarial search</strong> problems.</p>
<p>The algorithm described in this section is applicable for all games with the following characteristics:</p>
<div class="medium">
<p><span class="fragment">2 players</span> &nbsp; <span class="fragment">fully observable</span> &nbsp; <span class="fragment">deterministic</span> &nbsp; <span class="fragment">zero-sum</span></p>
</div>
<p>As in such games <span class="fragment">the state of a game is easy to represent,</span> <span class="fragment">agents are restricted to a few actions</span> <span class="fragment">and effects of actions are defined by precise rules <span class="citation" data-cites="RusselNorvig2022AIMA">(<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">Russel and Norvig 2022, 192</a>)</span>.</span></p>
</section>
<section id="minmax-value" class="level2">
<h2 data-anchor-id="minmax-value">MinMax value</h2>
<p>Given a state-space search tree, each node’s <strong>MinMax value</strong> is calculated.</p>
<p>The MinMax value is the best achievable utility of being in a given sate (against a rational adversary).</p>
<div class="incremental">
<ul class="incremental">
<li><code>MAX</code> prefers to move to a state of maximum value<br>
</li>
<li><code>MIN</code> prefers to move to a state of minimum value<br>
</li>
</ul>
</div>
</section>
<section id="adversarial-game-tree" class="level2">
<h2 data-anchor-id="adversarial-game-tree">Adversarial game tree</h2>
<div id="fig-adversarial-game-tree" class="quarto-float quarto-figure quarto-figure-left">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-adversarial-game-tree-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/adversarial-game-tree.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-5" title="Figure&nbsp;5: Example: A adversarial game tree"><img src="images/adversarial-game-tree.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-adversarial-game-tree-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5: Example: A adversarial game tree
</figcaption>
</figure>
</div>
<div class="notes">
<p>The △ nodes are “<code>MAX</code> nodes”, in which it is <code>MAX's</code> turn to move; the ▽ nodes are “<code>MIN</code> nodes”. <code>MAX's</code> best move at the root is α₁ (the highest MinMax value achievable at level 3), <code>MIN's</code> best move is β₁ (the lowest minimax value).</p>
</div>
</section>
<section id="minmax-algorithm" class="level2">
<h2 data-anchor-id="minmax-algorithm">MinMax algorithm</h2>
<p>The <strong>MinMax algorithm</strong> performs a complete depth-first exploration of the game tree <span class="citation" data-cites="RusselNorvig2022AIMA">(<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">Russel and Norvig 2022, 196–96</a>)</span>.</p>
<div class="incremental">
<ul class="incremental">
<li>Assumes that the adversary plays optimal.</li>
<li>Returns action whose terminal state has the optimal <strong>MinMax value</strong>.</li>
<li>The tree is calculated down to a maximum depth <span class="math inline">\(L\)</span> (i.e., the planning horizon).</li>
<li>If level <span class="math inline">\(L-1\)</span> belongs to <code>Min</code> MinMax will choose in each state the action, which leads to a successor of minimum utility — since minimum utility for <code>Max</code> is maximum utility of <code>Min</code>. Therefore, to each node in level <span class="math inline">\(L-1\)</span>, the minimum utility of it’s successor nodes is assigned.</li>
<li>In the same way to each node in level <span class="math inline">\(L-2\)</span>, the maximum utility of it’s successor nodes in level <span class="math inline">\(L-1\)</span> is assigned.</li>
<li>This process is repeated up to the root node. <code>Max</code> then knows his next action — the one, which yields to a successor with maximum utility-value.</li>
</ul>
</div>
<div class="notes">
<p>The exponential complexity makes the miminmax algorithm impractical for complex games (even with <a href="#Alpha-Beta-Pruning">Alpha-Beta Pruning</a> applied; chess game tree size &gt; atoms in the universe).</p>
</div>
</section>
<section id="alpha-beta-pruning" class="level2">
<h2 data-anchor-id="alpha-beta-pruning">Alpha-Beta Pruning</h2>
<p>Alpha-Beta Pruning is an improvement of the MinMax algorithm in the sense that it reduces the number of nodes, that have to be evaluated and generated by applying a simple logic <span class="citation" data-cites="RusselNorvig2022AIMA">(<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">Russel and Norvig 2022, 198–99</a>)</span>. The process is as follows:</p>
<div class="incremental">
<ul class="incremental">
<li>Alpha-beta pruning maintains two values during the tree traversal:
<ul class="incremental">
<li>α — The minimum score that the maximizing player (Max) is guaranteed to achieve (worst for Max)</li>
<li>β — The maximum score that the minimizing player (Min) is guaranteed to achieve (worst for Min)</li>
</ul></li>
<li>As the algorithm explores the tree:
<ul class="incremental">
<li>At maximizing nodes (<span class="math inline">\(L-2\)</span>), we update alpha if we find a better value</li>
<li>At minimizing nodes (<span class="math inline">\(L-1\)</span>), we update beta if we find a better value If at any node <span class="math inline">\(k\)</span> α ≥ β, we can stop exploring the current node’s remaining children (this is the pruning)</li>
</ul></li>
</ul>
</div>
<div class="notes">
<p>A nice simulation of MinMax- and AlphaBeta-Pruning can be found <a href="https://raphsilva.github.io/utilities/minimax_simulator/#">here</a>.</p>
<div class="callout callout-style-simple callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Why Alpha-Beta
</div>
</div>
<div class="callout-body-container callout-body">
<p>Pruning stops the search at the moment when it is determined that the value of a subtree is worse than the best solution already identified. Alpha-beta pruning gets its name from the two extra parameters in <em>MAX-VALUE(state,α,β)</em> that describe the bounds on the backed-up values that appear anywhere along the path:</p>
<ul>
<li>α = the value of the best choice for <code>MAX</code> found so far (“at least”)</li>
<li>β = the value of the bast choice for <code>MIN</code> found so far (“at most”)</li>
</ul>
<p>Alpha-beta search updates the values of α and β as it goes along and prunes the remaining branches at a node as soon as the value of the current node is known to be worse than the current α and β for <code>MAX</code> or <code>MIN</code>, respectively <span class="citation" data-cites="RusselNorvig2022AIMA">(<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">Russel and Norvig 2022, 198</a>)</span>.</p>
</div>
</div>
</div>
</section>
</section>
<section id="monte-carlo-tree-search" class="level1 headline-only" data-background-image="../assets/bg.jpeg">
<h1 class="headline-only" data-background-image="../assets/bg.jpeg">Monte Carlo tree search</h1>
<section id="introduction-1" class="level2">
<h2 data-anchor-id="introduction-1">Introduction</h2>
<p>The concept of a limited planning horizon, as applied in the MinMax-algorithm is one way to handle complex problems, which can not be planned to the goal-state in one step.</p>
<p>Another concept is to construct a tree until a final state in such a way that in each state only promising actions and corresponding successors are generated. This concept is applied by Monte Carlo tree search.</p>
</section>
<section id="functioning" class="level2">
<h2 data-anchor-id="functioning">Functioning</h2>
<p><strong>Monte Carlo tree search</strong> (MCTS)<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> does estimate the value of a state as the <strong>average utility</strong><a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> over a number of simulations of complete games starting from the current state <span class="citation" data-cites="RusselNorvig2022AIMA">(<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">Russel and Norvig 2022, 207–9</a>)</span>.</p>
<p>Each iteration follows four steps:</p>
<div class="incremental">
<ul class="incremental">
<li><strong>Selection:</strong> starting from the root node, apply tree policy in order to select next action (e.g., based on average utility<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a>).</li>
<li><strong>Expansion:</strong> in a leaf-node select an arbitrary action and generate the corresponding new child-node.</li>
<li><strong>Simulation:</strong> simulate the game, starting from the new child-node. At the end of each simulation the game is won or lost.</li>
<li><strong>Backpropagation:</strong> the result of the simulation is used to update all the search tree nodes going up to the root.</li>
</ul>
</div>
<p>If the computational budget is reached, MCTS returns with the best action a for the given root node.</p>
</section>
<section id="example-selection" class="level2">
<h2 data-anchor-id="example-selection">Example: selection</h2>
<div class="columns">
<div class="column">
<div id="fig-mcts-selection" class="quarto-float quarto-figure quarto-figure-left">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mcts-selection-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/mcts-selection.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-6" title="Figure&nbsp;6: Example: MCTS — selection"><img src="images/mcts-selection.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mcts-selection-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6: Example: MCTS — selection
</figcaption>
</figure>
</div>
</div><div class="column">
<p><a href="#fig-mcts-selection" class="quarto-xref">Figure&nbsp;6</a> shows a tree with the root representing a state where <code>P-A</code> has won 37/100 playouts done</p>
<div class="incremental">
<ul class="incremental">
<li><code>P-A</code> has just moved to the root node</li>
<li><code>P-B</code> selects a move to a node where it has won 60/79 playouts; this is the best win percentage among the available moves</li>
<li><code>P-A</code> will select a move to a node where it has won 16/53 playouts (assuming it plays optimally)</li>
<li><code>P-B</code> then continues on the leaf node marked 27/35</li>
<li>… until a terminal state is reached</li>
</ul>
</div>
</div>
</div>
<div class="notes">
<p>It would also have been reasonable to select the 2/11 node for the sake of exploration—with only 11 playouts, the node still has high uncertainty in its valuation, and might end up being the best option if more information about it is gained. So it makes sense to use a selection policy that balances exploitation and exploration.</p>
</div>
</section>
<section id="example-selection-policy-uct" class="level2">
<h2 data-anchor-id="example-selection-policy-uct">Example: selection policy (UCT)</h2>
<p><strong>Upper confidence bounds applied to trees</strong> (UCT) is a very effective selection policy ranking possible moves based on an upper confidence bound formula (UCB1)</p>
<p><span class="math display">\[
\textrm{UCB1}(n) = \frac{\textrm{U}(n)}{\textrm{N}(n)} + C * \sqrt{\frac{\log{\textrm{N}(\textrm{PARENT}(n))}}{\textrm{N}(n)}}
\]</span></p>
<div class="incremental">
<ul class="incremental">
<li><span class="math inline">\(\textrm{U}(n)\)</span> is the total utility of all playouts that went through node <span class="math inline">\(n\)</span></li>
<li><span class="math inline">\(\textrm{N}(n)\)</span> is the number of playouts through node <span class="math inline">\(n\)</span></li>
<li><span class="math inline">\(\textrm{PARENT}(n)\)</span> is the parent node of <span class="math inline">\(n\)</span> in the tree</li>
<li><span class="math inline">\(\frac{\textrm{U}(n)}{\textrm{N}(n)}\)</span> is the average utility of <span class="math inline">\(n\)</span> <em>(exploitation term, “how good are the stats?”)</em></li>
<li><span class="math inline">\(\frac{\log{\textrm{N}(\textrm{PARENT}(n))}}{\textrm{N}(n)}\)</span> is higher for <span class="math inline">\(n\)</span> only explored a few times<br>
<em>(exploration term, “how much has the child be ‘ignored’?”)</em></li>
<li><span class="math inline">\(C\)</span> is a constant that balance exploitation and exploration (theoretically <span class="math inline">\(\sqrt{2}\)</span>)</li>
</ul>
</div>
<div class="notes">
<p>With <span class="math inline">\(C=1.4\)</span>, the 60/79 node in <a href="#fig-mcts-selection" class="quarto-xref">Figure&nbsp;6</a> has the highest UCB1 score, but with <span class="math inline">\(C=1.5\)</span>, it would be the 2/11 node.</p>
</div>
</section>
<section id="example-expansion-and-simulation" class="level2">
<h2 data-anchor-id="example-expansion-and-simulation">Example: expansion and simulation</h2>
<div class="columns">
<div class="column">
<div id="fig-mcts-expansion" class="quarto-float quarto-figure quarto-figure-left">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mcts-expansion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/mcts-expansion-simulation.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-7" title="Figure&nbsp;7: Example: MCTS — expansion and simulation"><img src="images/mcts-expansion-simulation.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mcts-expansion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7: Example: MCTS — expansion and simulation
</figcaption>
</figure>
</div>
</div><div class="column">
<p><a href="#fig-mcts-expansion" class="quarto-xref">Figure&nbsp;7</a> shows a tree where a new child of the selected node is generated and marked with <code>0/0</code> <em>(expansion)</em>.</p>
<p>A playout for the newly generated child node is performed <em>(simulation)</em>.</p>
<div class="incremental">
<ul class="incremental">
<li>Moves for both players according the playout policy<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> are chosen</li>
<li>The moves are not recorded in the search tree</li>
<li>In <a href="#fig-mcts-expansion" class="quarto-xref">Figure&nbsp;7</a>, the simulation results in a win for <code>P-B</code></li>
</ul>
</div>
</div>
</div>
</section>
<section id="example-back-propagation" class="level2">
<h2 data-anchor-id="example-back-propagation">Example: back-propagation</h2>
<div class="columns">
<div class="column">
<div id="fig-mcts-propagation" class="quarto-float quarto-figure quarto-figure-left">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mcts-propagation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/mcts-back-propagation.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-8" title="Figure&nbsp;8: Example: MCTS — selection"><img src="images/mcts-back-propagation.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mcts-propagation-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;8: Example: MCTS — selection
</figcaption>
</figure>
</div>
</div><div class="column">
<p>The result of the simulation is used to update all the search tree nodes going up to the root.</p>
<div class="incremental">
<ul class="incremental">
<li><code>P-B's</code> nodes are incremented in both the number of wins and the number of playouts</li>
<li><code>P-A's</code> nodes are incremented in the number of playouts only</li>
</ul>
</div>
</div>
</div>
</section>
</section>
<section id="wrap-up" class="level1 headline-only" data-background-image="../assets/bg.jpeg">
<h1 class="headline-only" data-background-image="../assets/bg.jpeg">Wrap-up</h1>
<section id="search" class="level2">
<h2 data-anchor-id="search">Search</h2>
<p>Search operates over models of the world (which might be observed <em>online</em>)</p>
<div class="incremental">
<ul class="incremental">
<li>Agents do not try all possible plans</li>
<li>Planning is all “in simulation”</li>
<li>Search is only as good as the models are</li>
</ul>
</div>
</section>
<section id="adversarial-search-1" class="level2">
<h2 data-anchor-id="adversarial-search-1">Adversarial search</h2>
<div class="incremental">
<ul class="incremental">
<li>In two-player, discrete, deterministic, turn-taking zero-sum games with perfect information, the <strong>minimax algorithm</strong> can select optimal moves by a depth-first search in the game tree</li>
<li>Efficiency can be improved by using the <strong>alpha-beta</strong> search algorithm, which eliminates subtrees that are shown to be irrelevant.</li>
<li><strong>Monte Carlo tree search</strong> evaluates states by playing out the game all the way to the end to see who won. This playout <strong>simulation</strong> is repeated multiple times. The evaluation is an average of the results.</li>
</ul>
</div>
</section>
<section id="xkcd" class="level2">
<h2 data-anchor-id="xkcd">xkcd</h2>
<div id="fig-xkcd" class="quarto-float quarto-figure quarto-figure-left">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-xkcd-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/xkcd.png" class="lightbox" data-gallery="quarto-lightbox-gallery-9" title="Figure&nbsp;9: xkcd 1263: reassuring"><img src="images/xkcd.png" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-xkcd-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;9: xkcd 1263: reassuring
</figcaption>
</figure>
</div>
</section>
</section>
<section id="exercises" class="level1 headline-only" data-background-color="black">
<h1 class="headline-only" data-background-color="black">Exercises</h1>
<section id="definition-sequence" class="level2">
<h2 data-anchor-id="definition-sequence">Definition sequence</h2>
<blockquote class="blockquote">
<p>Problem formulation must follow goal formulation.</p>
</blockquote>
<p>Discuss that statement. Is it true or false? Why?</p>
</section>
<section id="problem-formulation" class="level2">
<h2 data-anchor-id="problem-formulation">Problem formulation</h2>
<p>Give a complete problem formulation for each of the following problems. Choose a formulation that is precise enough to be implemented.</p>
<ul>
<li>There are six glass boxes in a row, each with a lock. Each of the first five boxes holds a key unlocking the next box in line; the last box holds a banana. You have the key to the first box, and you want the banana.</li>
<li>There is an <em>n x n</em> grid of squares, each square initially being either unpainted floor or a bottomless pit. You start standing on an unpainted floor square, and can either paint the square under you or move into an adjacent unpainted floor square. You want the whole floor painted.</li>
</ul>
</section>
<section id="maze" class="level2">
<h2 data-anchor-id="maze">Maze</h2>
<p>Your goal is to navigate a robot out of a maze. It starts in the center of the maze facing north. You can turn the robot to face north, east, south, or west; direct the robot to move forward a certain distance (it will stop before a wall).</p>
<ol type="a">
<li>Formally define this problem as a search problem. How large is the state space?</li>
<li>In navigating a maze, the only place we need to turn is at the intersection of two or more corridors. Reformulate this problem using this observation. How large is the state space now?</li>
<li>From each point in the maze, we can move in any of the four directions until we reach a turning point, and this is the only action we need to do. Reformulate the problem using these actions. Do we need to keep track of the robot’s orientation now?</li>
<li>In our initial description of the problem we already abstracted from the real world. Name three such simplifications we made.</li>
</ol>
<div class="notes">
<div class="callout callout-style-simple callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-9-contents" aria-controls="callout-9" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Solution notes
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-9" class="callout-9-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div id="fig-maze" class="quarto-float quarto-figure quarto-figure-left">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-maze-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/maze.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-10" title="Figure&nbsp;10: Solution note for the maze exercise"><img src="images/maze.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-maze-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;10: Solution note for the maze exercise
</figcaption>
</figure>
</div>
<p><span class="h4">Problem statement</span></p>
<ul>
<li>The center of the maze is at (0; 0), and the maze itself is a square from (-1;-1) to (1; 1).</li>
<li><strong>Initial state:</strong> robot at coordinate (0; 0), facing North.</li>
<li><strong>Goal test:</strong> either jxj &gt; 1 or jyj &gt; 1 where (x; y) is the current location.</li>
<li><strong>Successor function:</strong> move forwards any distance d; change direction robot it facing.</li>
<li><strong>Cost function:</strong> total distance moved.</li>
</ul>
<p>The state space is infinitely large, since the robot’s position is continuous.</p>
<p><span class="h4">Reformulated problem statement</span></p>
<p>The state will record the intersection the robot is currently at, along with the direction it’s facing. At the end of each corridor leaving the maze we will have an exit node. We’ll assume some node corresponds to the center of the maze.</p>
<ul>
<li><strong>Initial state:</strong> at the center of the maze facing North.</li>
<li><strong>Goal test:</strong> at an exit node.</li>
<li><strong>Successor function:</strong> move to the next intersection in front of us, if there is one; turn to face a new direction.</li>
<li><strong>Cost function:</strong> total distance moved.</li>
</ul>
<p>There are 4n states, where n is the number of intersections.</p>
<p><span class="h4">Reformulated problem statement #2</span></p>
<ul>
<li><strong>Initial state:</strong> at the center of the maze.</li>
<li><strong>Goal test:</strong> at an exit node.</li>
<li><strong>Successor function:</strong> move to next intersection to the North, South, East, or West.</li>
<li><strong>Cost function:</strong> total distance moved.</li>
</ul>
<p>We no longer need to keep track of the robot’s orientation since it is irrelevant to predicting the outcome of our actions, and not part of the goal test. The motor system that executes this plan will need to keep track of the robot’s current orientation, to know when to rotate the robot.</p>
<p><span class="h4">Abstractions</span></p>
<p><strong>State:</strong></p>
<ul>
<li>Ignoring the height of the robot off the ground, whether it is tilted off the vertical.</li>
<li>The robot can face in only four directions.</li>
<li>Other parts of the world ignored: possibility of other robots in the maze, the weather in the Caribbean.</li>
</ul>
<p><strong>Action:</strong></p>
<ul>
<li>We assumed all positions we safely accessible: the robot couldn’t get stuck or damaged.</li>
<li>The robot can move as far as it wants, without having to recharge its batteries.</li>
<li>Simplified movement system: moving forwards a certain distance, rather than controlled each individual motor and watching the sensors to detect collisions.</li>
</ul>
</div>
</div>
</div>
</div>
</section>
<section id="concepts" class="level2">
<h2 data-anchor-id="concepts">Concepts</h2>
<p>Explain in your own words the following terms:</p>
<ul>
<li>Zero-sum</li>
<li>Terminal test</li>
<li>Minimax value</li>
<li>Selection policy</li>
<li>Playout policy</li>
<li>Monte Carlo tree</li>
<li>Back-propagation</li>
</ul>
</section>
<section id="minimax" class="level2">
<h2 data-anchor-id="minimax">MINIMAX</h2>
<p>Explain if the <code>MINIMAX</code> algorithm is complete and optimal.</p>
<p>Can it be beaten by an opponent playing suboptimally? Why (not)?</p>
<p>Come up with a game tree in which MAX will beat a suboptimal MIN.</p>
<div class="notes">
<div class="callout callout-style-simple callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-10-contents" aria-controls="callout-10" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Solution notes
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-10" class="callout-10-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><strong>Completeness</strong></p>
<p>In two-player, discrete, deterministic, turn-taking zero-sum games with perfect information, the <code>MINIMAX</code> algorithm can select optimal moves by a depth-first emuration, the algorithm is also guaranteed to find a solution when there is one.</p>
<p>The algorithm performs a complete depth-first exploration of the game tree. If the maximum depth of the tree is <span class="math inline">\(m\)</span> and there are <span class="math inline">\(b\)</span> legal moves at each point, then the time complexity is <span class="math inline">\(O(b^m)\)</span> for an algorithm that generates all actions at once, or <span class="math inline">\(O(m)\)</span> for an algorithm that generates actions on at a time. The exponential complexity makes <code>MINIMAX</code> impractical for complex games. <code>MINIMAX</code> does, however, serve as a basis for the mathematical analysis for games. By approximating the minimax analysis in various ways, we can derive more practical algorithms.</p>
<p><strong>Suboptimally play</strong></p>
<p>If <em>MIN</em> does not play optimally, then <em>MAX</em> will do at least as well as against an optimal player, possibly better.</p>
</div>
</div>
</div>
</div>
</section>
<section id="pruning" class="level2">
<h2 data-anchor-id="pruning">Pruning</h2>
<p>Read the note about pruning (and consult <span class="citation" data-cites="RusselNorvig2022AIMA">Russel and Norvig (<a href="#ref-RusselNorvig2022AIMA" role="doc-biblioref">2022</a>)</span> if necessary).</p>
<p>Explain in your own words, under what conditions a subtree is skipped using Alpha-beta pruning.</p>
<p>Draw an example (game search tree, 3 levels depth).</p>
<div class="notes">
<div class="callout callout-style-simple callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-11-contents" aria-controls="callout-11" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Solution notes
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-11" class="callout-11-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div id="fig-pruning" class="quarto-float quarto-figure quarto-figure-left">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-pruning-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<a href="images/pruning.svg" class="lightbox" data-gallery="quarto-lightbox-gallery-11" title="Figure&nbsp;11: Example for pruning"><img src="images/pruning.svg" class="img-fluid figure-img"></a>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-pruning-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;11: Example for pruning
</figcaption>
</figure>
</div>
<p><a href="#fig-pruning" class="quarto-xref">Figure&nbsp;11</a>: There is no point in looking at the other successor states of <em>C</em>, thus it can be skipped.</p>
</div>
</div>
</div>
</div>
</section>
</section>
<section id="literature" class="level1">
<h1>Literature</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-RusselNorvig2022AIMA" class="csl-entry" role="listitem">
Russel, Stuart, and Peter Norvig. 2022. <em>Artificial Intelligence: A Modern Approach</em>. Harlow: Pearson Education.
</div>
</div>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>An <strong>atomic representation</strong> is one in which each state is treated as a black box with not internal structure, meaning the state either does or does not match what you’re looking for.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Problem formulation is specifically about defining the formal components of a search problem (state space, initial state, goal state, actions, etc.) — it’s about translating a real-world problem into the specific mathematical structure needed for search algorithms.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>A state is a situation that an agent can find itself in.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Expressed by a graph whose nodes are the set of all states, and whose links are actions that transform one state into another<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>Can be a single goal state, a small set of alternative goal states, or a property that applies to many states (e.g, no dirt in any location)<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>First-in-first-out (FIFO) queue first pops the node that was added to the queue first<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>Last-in-first-out queue (LIFO; also known as a stack) pops first the most recently added node<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>First pops the node with the minimum costs according to <span class="math inline">\(f(n)\)</span><a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p><a href="https://jonathan-hui.medium.com/monte-carlo-tree-search-mcts-in-alphago-zero-8a403588276a">Reading recommendation</a><a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>The average utility is guided by the <strong>selection policy</strong>.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>For games with binary outcomes, <strong>average utility</strong> equals <em>win percentage</em><a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>Playout policies biases the moves toward good ones. For Go and other games, playout policies have been successfully learned from self-play by using neural networks. Sometimes also game-specific heuristics are used (e.g., take the corner square in Othello)<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/awe-hnu\.github\.io");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
 Copyright 2025, Andy Weeger
  </li>  
</ul>
    </div>   
    <div class="nav-footer-center">

<div class="cookie-consent-footer"><a href="#" id="open_preferences_center">Cookie Preferences</a></div></div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../../index.html">
<p>Start</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../../../../about.html">
<p>About</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="https://www.hnu.de" target="_blank">
<p>HNU</p>
</a>
  </li>  
    <li class="nav-item">
    <a class="nav-link" href="../../../../imprint.html">
<p>Imprint</p>
</a>
  </li>  
</ul>
    </div>
  </div>
</footer>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>